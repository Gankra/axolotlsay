# Copyright 2022-2023, axodotdev
# SPDX-License-Identifier: MIT or Apache-2.0
#
# CI that:
#
# * checks for a Git Tag that looks like a release
# * creates a Github Release™ and fills in its text
# * builds artifacts with cargo-dist (executable-zips, installers)
# * uploads those artifacts to the Github Release™
#
# Note that the Github Release™ will be created before the artifacts,
# so there will be a few minutes where the release has no artifacts
# and then they will slowly trickle in, possibly failing. To make
# this more pleasant we mark the release as a "draft" until all
# artifacts have been successfully uploaded. This allows you to
# choose what to do with partial successes and avoids spamming
# anyone with notifications before the release is actually ready.
name: Release

permissions:
  contents: write

# This task will run whenever you push a git tag that looks like a version
# like "v1", "v1.2.0", "v0.1.0-prerelease01", "my-app-v1.0.0", etc.
# The version will be roughly parsed as ({PACKAGE_NAME}-)?v{VERSION}, where
# PACKAGE_NAME must be the name of a Cargo package in your workspace, and VERSION
# must be a Cargo-style SemVer Version.
#
# If PACKAGE_NAME is specified, then we will create a Github Release™ for that
# package (erroring out if it doesn't have the given version or isn't cargo-dist-able).
#
# If PACKAGE_NAME isn't specified, then we will create a Github Release™ for all
# (cargo-dist-able) packages in the workspace with that version (this is mode is
# intended for workspaces with only one dist-able package, or with all dist-able
# packages versioned/released in lockstep).
#
# If you push multiple tags at once, separate instances of this workflow will
# spin up, creating an independent Github Release™ for each one.
#
# If there's a prerelease-style suffix to the version then the Github Release™
# will be marked as a prerelease.
on:
  push:
    tags:
      - '*-?v[0-9]+*'

jobs:
  plan:
    # run cargo dist plan to figure out what we're doing
    runs-on: ubuntu-latest
    outputs:
      val: ${{ steps.plan.outputs.manifest }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive
      - uses: swatinem/rust-cache@v2
      - name: Install cargo-dist
        run: "cargo install --git https://github.com/axodotdev/cargo-dist/ --branch=ci-plus cargo-dist"
      - id: plan
        run: |
          cargo dist plan --tag=${{ github.ref_name }} --output-format=json > dist-manifest.json
          echo "cargo dist plan ran successfully"
          cat dist-manifest.json
          echo "manifest=$(jq -c dist-manifest.json)" >> "$GITHUB_OUTPUT"
      - name: "Upload dist-manifest.json"
        uses: actions/upload-artifact@v3
        with:
          name: artifacts
          path: dist-manifest.json

  upload-dist-artifacts:
    # Build and packages all the things
    needs: plan
    # Let the initial task tell us to not run (currently very blunt)
    if: ${{ fromJson(needs.plan.outputs.val).releases != null }}
    strategy:
      fail-fast: false
      # Target platforms/runners are computed by cargo-dist in create-release.
      # Each member of the matrix has the following arguments:
      #
      # - runner: the github runner
      # - dist-args: cli flags to pass to cargo dist
      # - install-dist: expression to run to install cargo-dist on the runner
      #
      # Typically there will be:
      # - 1 "global" task that builds universal installers
      # - N "local" tasks that build each platform's binaries and platform-specific installers
      matrix: ${{ fromJson(needs.plan.outputs.val).ci.github.artifacts-matrix }}
    runs-on: ${{ matrix.runner }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive
      - uses: swatinem/rust-cache@v2
      - name: Install cargo-dist
        run: ${{ matrix.install-dist }}
      - id: cargo-dist
        # We force bash here just because github makes it really hard to get values up
        # to "real" actions without writing to env-vars, and writing to env-vars has
        # inconsistent syntax between shell and powershell. cargo-dist and jq work fine
        # in powershell.
        shell: bash
        # This logic is a bit janky because it's trying to be a polyglot between
        # powershell and bash since this will run on windows, macos, and linux!
        # The two platforms don't agree on how to talk about env vars but they
        # do agree on 'cat' and '$()' so we use that to marshal values between commands.
        run: |
          # Actually do builds and make zips and whatnot
          cargo dist build --tag=${{ github.ref_name }} --output-format=json ${{ matrix.dist-args }} > dist-manifest.json
          echo "dist ran successfully"
          cat dist-manifest.json

          # Parse out what we just built and upload it to the Github Release™
          echo "paths=$(jq --raw-output ".artifacts[]?.path | select( . != null )")" >> "$GITHUB_OUTPUT"
      - name: "Upload artifacts"
        uses: actions/upload-artifact@v3
        with:
          name: artifacts
          path: ${{ steps.cargo-dist.outputs.paths }}

  publish-release:
    # Create a Github Release with all the results once everything is done,
    # regardless of success. The release is only marked as non-draft if all tasks succeeded.
    needs:
      - plan
      - upload-dist-artifacts
    if: ${{ always() }}
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive
      - id: manifest
        run: |
          echo "${{ needs.plan.outputs.val }}" >> dist-manifest.json
          echo "title=$(jq --raw-output ".announcement_title" dist-manifest.json)" >> "$GITHUB_OUTPUT"
          echo "prerelease=$(jq --raw-output ".announcement_is_prerelease" dist-manifest.json)" >> "$GITHUB_OUTPUT"
          echo "body=$(jq --raw-output ".announcement_github_body" dist-manifest.json > new_dist_announcement.md)" >> "$GITHUB_OUTPUT"
      - name: "Download artifacts"
        uses: actions/download-artifact@v3
        with:
          name: artifacts
          path: artifacts
      - name: Create Release
        id: create_release
        uses: ncipollo/release-action@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token
        with:
          tag: ${{ github.ref }}
          name: ${{ steps.manifest.outputs.title }}
          body: ${{ steps.manifest.outputs.body }}
          draft: ${{ needs.plan.result == 'success' && (needs.upload-dist-artifacts.result == 'skipped' || needs.upload-dist-artifacts.result == 'success') }}
          prerelease: ${{ steps.manifest.outputs.prerelease }}
          artifacts: "artifacts/*"
